{"/home/travis/build/npmtest/node-npmtest-docopt/test.js":"/* istanbul instrument in package npmtest_docopt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-docopt/lib.npmtest_docopt.js":"/* istanbul instrument in package npmtest_docopt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_docopt = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_docopt = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-docopt/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-docopt && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_docopt */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_docopt\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_docopt.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_docopt.rollup.js'] =\n            local.assetsDict['/assets.npmtest_docopt.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_docopt.__dirname + '/lib.npmtest_docopt.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-docopt/node_modules/docopt/docopt.js":"// Generated by CoffeeScript 1.9.1\n(function() {\n  var Argument, BranchPattern, Command, Dict, DocoptExit, DocoptLanguageError, Either, LeafPattern, OneOrMore, Option, Optional, OptionsShortcut, Pattern, Required, Tokens, any, docopt, enumerate, extras, formal_usage, parse_argv, parse_atom, parse_defaults, parse_expr, parse_long, parse_pattern, parse_section, parse_seq, parse_shorts, print, transform, zip,\n    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    slice = [].slice,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  print = function() {\n    return console.log([].join.call(arguments, ' '));\n  };\n\n  enumerate = function(array) {\n    var i, item, j, len, results;\n    i = 0;\n    results = [];\n    for (j = 0, len = array.length; j < len; j++) {\n      item = array[j];\n      results.push([i++, item]);\n    }\n    return results;\n  };\n\n  any = function(array) {\n    return indexOf.call(array, true) >= 0;\n  };\n\n  zip = function() {\n    var args, arr, i, j, length, lengthArray, ref, results;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    lengthArray = (function() {\n      var j, len, results;\n      results = [];\n      for (j = 0, len = args.length; j < len; j++) {\n        arr = args[j];\n        results.push(arr.length);\n      }\n      return results;\n    })();\n    length = Math.min.apply(Math, lengthArray);\n    results = [];\n    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      results.push((function() {\n        var len, q, results1;\n        results1 = [];\n        for (q = 0, len = args.length; q < len; q++) {\n          arr = args[q];\n          results1.push(arr[i]);\n        }\n        return results1;\n      })());\n    }\n    return results;\n  };\n\n  String.prototype.partition = function(separator) {\n    var parts, self;\n    self = this;\n    if (self.indexOf(separator) >= 0) {\n      parts = self.split(separator);\n      return [parts[0], separator, parts.slice(1).join(separator)];\n    } else {\n      return [String(self), '', ''];\n    }\n  };\n\n  String.prototype.startsWith = function(searchString, position) {\n    position = position || 0;\n    return this.lastIndexOf(searchString, position) === position;\n  };\n\n  String.prototype.endsWith = function(searchString, position) {\n    var lastIndex, subjectString;\n    subjectString = this.toString();\n    if (position === void 0 || position > subjectString.length) {\n      position = subjectString.length;\n    }\n    position -= searchString.length;\n    lastIndex = subjectString.indexOf(searchString, position);\n    return lastIndex !== -1 && lastIndex === position;\n  };\n\n  String.prototype._split = function() {\n    return this.trim().split(/\\s+/).filter(function(i) {\n      return i !== '';\n    });\n  };\n\n  String.prototype.isUpper = function() {\n    return /^[A-Z]+$/g.exec(this);\n  };\n\n  Number.isInteger = Number.isInteger || function(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n  };\n\n  DocoptLanguageError = (function(superClass) {\n    extend(DocoptLanguageError, superClass);\n\n    function DocoptLanguageError(message) {\n      this.message = message;\n      DocoptLanguageError.__super__.constructor.call(this, this.message);\n    }\n\n    return DocoptLanguageError;\n\n  })(Error);\n\n  DocoptExit = (function(superClass) {\n    extend(DocoptExit, superClass);\n\n    function DocoptExit(message) {\n      this.message = message;\n      DocoptExit.__super__.constructor.call(this, this.message);\n    }\n\n    return DocoptExit;\n\n  })(Error);\n\n  Pattern = (function(superClass) {\n    extend(Pattern, superClass);\n\n    function Pattern() {\n      return Pattern.__super__.constructor.apply(this, arguments);\n    }\n\n    Pattern.prototype.fix = function() {\n      this.fix_identities();\n      this.fix_repeating_arguments();\n      return this;\n    };\n\n    Pattern.prototype.fix_identities = function(uniq) {\n      var c, flat, i, j, k, len, len1, q, ref, ref1, ref2;\n      if (uniq == null) {\n        uniq = null;\n      }\n      \"Make pattern-tree tips point to same object if they are equal.\";\n      if (!this.hasOwnProperty('children')) {\n        return this;\n      }\n      if (uniq === null) {\n        ref = [{}, this.flat()], uniq = ref[0], flat = ref[1];\n        for (j = 0, len = flat.length; j < len; j++) {\n          k = flat[j];\n          uniq[k] = k;\n        }\n      }\n      ref1 = enumerate(this.children);\n      for (q = 0, len1 = ref1.length; q < len1; q++) {\n        ref2 = ref1[q], i = ref2[0], c = ref2[1];\n        if (!c.hasOwnProperty('children')) {\n          console.assert(uniq.hasOwnProperty(c));\n          this.children[i] = uniq[c];\n        } else {\n          c.fix_identities(uniq);\n        }\n      }\n      return this;\n    };\n\n    Pattern.prototype.fix_repeating_arguments = function() {\n      \"Fix elements that should accumulate/increment values.\";\n      var c, child, counts, e, either, j, len, len1, len2, mycase, q, r, ref;\n      either = (function() {\n        var j, len, ref, results;\n        ref = transform(this).children;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          child = ref[j];\n          results.push(child.children);\n        }\n        return results;\n      }).call(this);\n      for (j = 0, len = either.length; j < len; j++) {\n        mycase = either[j];\n        counts = {};\n        for (q = 0, len1 = mycase.length; q < len1; q++) {\n          c = mycase[q];\n          counts[c] = (counts[c] ? counts[c] : 0) + 1;\n        }\n        ref = (function() {\n          var len2, results, u;\n          results = [];\n          for (u = 0, len2 = mycase.length; u < len2; u++) {\n            child = mycase[u];\n            if (counts[child] > 1) {\n              results.push(child);\n            }\n          }\n          return results;\n        })();\n        for (r = 0, len2 = ref.length; r < len2; r++) {\n          e = ref[r];\n          if (e.constructor === Argument || e.constructor === Option && e.argcount) {\n            if (e.value === null) {\n              e.value = [];\n            } else if (e.value.constructor !== Array) {\n              e.value = e.value._split();\n            }\n          }\n          if (e.constructor === Command || e.constructor === Option && e.argcount === 0) {\n            e.value = 0;\n          }\n        }\n      }\n      return this;\n    };\n\n    return Pattern;\n\n  })(Object);\n\n  transform = function(pattern) {\n    \"Expand pattern into an (almost) equivalent one, but with single Either.\\n\\nExample: ((-a | -b) (-c | -d)) => (-a -c | -a -d | -b -c | -b -d)\\nQuirks: [-a] => (-a), (-a...) => (-a -a)\\n\";\n    var c, child, children, e, groups, index, j, len, parents, ref, result, t;\n    result = [];\n    groups = [[pattern]];\n    while (groups.length) {\n      children = groups.shift();\n      parents = [Required, Optional, OptionsShortcut, Either, OneOrMore];\n      if (any((function() {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = parents.length; j < len; j++) {\n          t = parents[j];\n          results.push(indexOf.call(children.map(function(c) {\n            return c.constructor;\n          }), t) >= 0);\n        }\n        return results;\n      })())) {\n        child = ((function() {\n          var j, len, ref, results;\n          results = [];\n          for (j = 0, len = children.length; j < len; j++) {\n            c = children[j];\n            if (ref = c.constructor, indexOf.call(parents, ref) >= 0) {\n              results.push(c);\n            }\n          }\n          return results;\n        })())[0];\n        index = children.indexOf(child);\n        if (index >= 0) {\n          children.splice(index, 1);\n        }\n        if (child.constructor === Either) {\n          ref = child.children;\n          for (j = 0, len = ref.length; j < len; j++) {\n            c = ref[j];\n            groups.push([c].concat(children));\n          }\n        } else if (child.constructor === OneOrMore) {\n          groups.push((child.children.concat(child.children)).concat(children));\n        } else {\n          groups.push(child.children.concat(children));\n        }\n      } else {\n        result.push(children);\n      }\n    }\n    return new Either((function() {\n      var len1, q, results;\n      results = [];\n      for (q = 0, len1 = result.length; q < len1; q++) {\n        e = result[q];\n        results.push(new Required(e));\n      }\n      return results;\n    })());\n  };\n\n  LeafPattern = (function(superClass) {\n    \"Leaf/terminal node of a pattern tree.\";\n    extend(LeafPattern, superClass);\n\n    function LeafPattern(name1, value1) {\n      this.name = name1;\n      this.value = value1 != null ? value1 : null;\n    }\n\n    LeafPattern.prototype.toString = function() {\n      return this.constructor.name + \"(\" + this.name + \", \" + this.value + \")\";\n    };\n\n    LeafPattern.prototype.flat = function(types) {\n      var ref;\n      if (types == null) {\n        types = [];\n      }\n      types = types instanceof Array ? types : [types];\n      if (!types.length || (ref = this.constructor, indexOf.call(types, ref) >= 0)) {\n        return [this];\n      } else {\n        return [];\n      }\n    };\n\n    LeafPattern.prototype.match = function(left, collected) {\n      var a, increment, left_, match, pos, ref, same_name;\n      if (collected == null) {\n        collected = null;\n      }\n      if (collected === null) {\n        collected = [];\n      }\n      ref = this.singleMatch(left), pos = ref[0], match = ref[1];\n      if (match === null) {\n        return [false, left, collected];\n      }\n      left_ = left.slice(0, pos).concat(left.slice(pos + 1));\n      same_name = (function() {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = collected.length; j < len; j++) {\n          a = collected[j];\n          if (a.name === this.name) {\n            results.push(a);\n          }\n        }\n        return results;\n      }).call(this);\n      if (Number.isInteger(this.value) || this.value instanceof Array) {\n        if (Number.isInteger(this.value)) {\n          increment = 1;\n        } else {\n          increment = typeof match.value === 'string' ? [match.value] : match.value;\n        }\n        if (!same_name.length) {\n          match.value = increment;\n          return [true, left_, collected.concat(match)];\n        }\n        if (Number.isInteger(this.value)) {\n          same_name[0].value += increment;\n        } else {\n          same_name[0].value = [].concat(same_name[0].value, increment);\n        }\n        return [true, left_, collected];\n      }\n      return [true, left_, collected.concat(match)];\n    };\n\n    return LeafPattern;\n\n  })(Pattern);\n\n  BranchPattern = (function(superClass) {\n    \"Branch/inner node of a pattern tree.\";\n    extend(BranchPattern, superClass);\n\n    function BranchPattern(children) {\n      this.children = children instanceof Array ? children : [children];\n    }\n\n    BranchPattern.prototype.toString = function() {\n      var a;\n      return this.constructor.name + \"(\" + (((function() {\n        var j, len, ref, results;\n        ref = this.children;\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          a = ref[j];\n          results.push(a);\n        }\n        return results;\n      }).call(this)).join(', ')) + \")\";\n    };\n\n    BranchPattern.prototype.flat = function(types) {\n      var child, ref;\n      if (types == null) {\n        types = [];\n      }\n      types = types instanceof Array ? types : [types];\n      if (ref = this.constructor, indexOf.call(types, ref) >= 0) {\n        return [this];\n      }\n      return ((function() {\n        var j, len, ref1, results;\n        ref1 = this.children;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (child instanceof Pattern) {\n            results.push(child.flat(types));\n          }\n        }\n        return results;\n      }).call(this)).reduce((function(pv, cv) {\n        return [].concat(pv, cv);\n      }), []);\n    };\n\n    return BranchPattern;\n\n  })(Pattern);\n\n  Argument = (function(superClass) {\n    extend(Argument, superClass);\n\n    function Argument() {\n      return Argument.__super__.constructor.apply(this, arguments);\n    }\n\n    Argument.prototype.singleMatch = function(left) {\n      var j, len, n, pattern, ref, ref1;\n      ref = enumerate(left);\n      for (j = 0, len = ref.length; j < len; j++) {\n        ref1 = ref[j], n = ref1[0], pattern = ref1[1];\n        if (pattern.constructor === Argument) {\n          return [n, new Argument(this.name, pattern.value)];\n        }\n      }\n      return [null, null];\n    };\n\n    Argument.parse = function(source) {\n      var name, value;\n      name = /(<\\S*?>)/ig.exec(source)[1];\n      value = /\\[default:\\s+(.*)\\]/ig.exec(source);\n      return new Argument(name, value ? value[1] : null);\n    };\n\n    return Argument;\n\n  })(LeafPattern);\n\n  Command = (function(superClass) {\n    extend(Command, superClass);\n\n    function Command(name1, value1) {\n      this.name = name1;\n      this.value = value1 != null ? value1 : false;\n    }\n\n    Command.prototype.singleMatch = function(left) {\n      var j, len, n, pattern, ref, ref1;\n      ref = enumerate(left);\n      for (j = 0, len = ref.length; j < len; j++) {\n        ref1 = ref[j], n = ref1[0], pattern = ref1[1];\n        if (pattern.constructor === Argument) {\n          if (pattern.value === this.name) {\n            return [n, new Command(this.name, true)];\n          } else {\n            break;\n          }\n        }\n      }\n      return [null, null];\n    };\n\n    return Command;\n\n  })(Argument);\n\n  Option = (function(superClass) {\n    extend(Option, superClass);\n\n    function Option(short1, long1, argcount1, value) {\n      var ref;\n      this.short = short1 != null ? short1 : null;\n      this.long = long1 != null ? long1 : null;\n      this.argcount = argcount1 != null ? argcount1 : 0;\n      if (value == null) {\n        value = false;\n      }\n      console.assert((ref = this.argcount) === 0 || ref === 1);\n      this.value = value === false && this.argcount > 0 ? null : value;\n      this.name = this.long || this.short;\n    }\n\n    Option.prototype.toString = function() {\n      return \"Option(\" + this.short + \", \" + this.long + \", \" + this.argcount + \", \" + this.value + \")\";\n    };\n\n    Option.parse = function(option_description) {\n      var _, argcount, description, j, len, long, matched, options, ref, ref1, ref2, s, short, value;\n      ref = [null, null, 0, false], short = ref[0], long = ref[1], argcount = ref[2], value = ref[3];\n      ref1 = option_description.trim().partition('  '), options = ref1[0], _ = ref1[1], description = ref1[2];\n      options = options.replace(/,|=/g, ' ');\n      ref2 = options._split();\n      for (j = 0, len = ref2.length; j < len; j++) {\n        s = ref2[j];\n        if (s.startsWith('--')) {\n          long = s;\n        } else if (s.startsWith('-')) {\n          short = s;\n        } else {\n          argcount = 1;\n        }\n      }\n      if (argcount > 0) {\n        matched = /\\[default:\\s+(.*)\\]/ig.exec(description);\n        value = matched ? matched[1] : null;\n      }\n      return new Option(short, long, argcount, value);\n    };\n\n    Option.prototype.singleMatch = function(left) {\n      var j, len, n, pattern, ref, ref1;\n      ref = enumerate(left);\n      for (j = 0, len = ref.length; j < len; j++) {\n        ref1 = ref[j], n = ref1[0], pattern = ref1[1];\n        if (this.name === pattern.name) {\n          return [n, pattern];\n        }\n      }\n      return [null, null];\n    };\n\n    return Option;\n\n  })(LeafPattern);\n\n  Required = (function(superClass) {\n    extend(Required, superClass);\n\n    function Required() {\n      return Required.__super__.constructor.apply(this, arguments);\n    }\n\n    Required.prototype.match = function(left, collected) {\n      var c, j, l, len, matched, p, ref, ref1;\n      if (collected == null) {\n        collected = null;\n      }\n      if (collected === null) {\n        collected = [];\n      }\n      l = left;\n      c = collected;\n      ref = this.children;\n      for (j = 0, len = ref.length; j < len; j++) {\n        p = ref[j];\n        ref1 = p.match(l, c), matched = ref1[0], l = ref1[1], c = ref1[2];\n        if (!matched) {\n          return [false, left, collected];\n        }\n      }\n      return [true, l, c];\n    };\n\n    return Required;\n\n  })(BranchPattern);\n\n  Optional = (function(superClass) {\n    extend(Optional, superClass);\n\n    function Optional() {\n      return Optional.__super__.constructor.apply(this, arguments);\n    }\n\n    Optional.prototype.match = function(left, collected) {\n      var j, len, m, p, ref, ref1;\n      if (collected == null) {\n        collected = null;\n      }\n      if (collected === null) {\n        collected = [];\n      }\n      ref = this.children;\n      for (j = 0, len = ref.length; j < len; j++) {\n        p = ref[j];\n        ref1 = p.match(left, collected), m = ref1[0], left = ref1[1], collected = ref1[2];\n      }\n      return [true, left, collected];\n    };\n\n    return Optional;\n\n  })(BranchPattern);\n\n  OptionsShortcut = (function(superClass) {\n    \"Marker/placeholder for [options] shortcut.\";\n    extend(OptionsShortcut, superClass);\n\n    function OptionsShortcut() {\n      return OptionsShortcut.__super__.constructor.apply(this, arguments);\n    }\n\n    return OptionsShortcut;\n\n  })(Optional);\n\n  OneOrMore = (function(superClass) {\n    extend(OneOrMore, superClass);\n\n    function OneOrMore() {\n      return OneOrMore.__super__.constructor.apply(this, arguments);\n    }\n\n    OneOrMore.prototype.match = function(left, collected) {\n      var c, l, l_, matched, ref, times;\n      if (collected == null) {\n        collected = null;\n      }\n      console.assert(this.children.length === 1);\n      if (collected === null) {\n        collected = [];\n      }\n      l = left;\n      c = collected;\n      l_ = [];\n      matched = true;\n      times = 0;\n      while (matched) {\n        ref = this.children[0].match(l, c), matched = ref[0], l = ref[1], c = ref[2];\n        times += matched ? 1 : 0;\n        if (l_.join(', ') === l.join(', ')) {\n          break;\n        }\n        l_ = l;\n      }\n      if (times >= 1) {\n        return [true, l, c];\n      }\n      return [false, left, collected];\n    };\n\n    return OneOrMore;\n\n  })(BranchPattern);\n\n  Either = (function(superClass) {\n    extend(Either, superClass);\n\n    function Either() {\n      return Either.__super__.constructor.apply(this, arguments);\n    }\n\n    Either.prototype.match = function(left, collected) {\n      var j, len, outcome, outcomes, p, ref;\n      if (collected == null) {\n        collected = null;\n      }\n      if (collected === null) {\n        collected = [];\n      }\n      outcomes = [];\n      ref = this.children;\n      for (j = 0, len = ref.length; j < len; j++) {\n        p = ref[j];\n        outcome = p.match(left, collected);\n        if (outcome[0]) {\n          outcomes.push(outcome);\n        }\n      }\n      if (outcomes.length > 0) {\n        outcomes.sort(function(a, b) {\n          if (a[1].length > b[1].length) {\n            return 1;\n          } else if (a[1].length < b[1].length) {\n            return -1;\n          } else {\n            return 0;\n          }\n        });\n        return outcomes[0];\n      }\n      return [false, left, collected];\n    };\n\n    return Either;\n\n  })(BranchPattern);\n\n  Tokens = (function(superClass) {\n    extend(Tokens, superClass);\n\n    function Tokens(source, error) {\n      var stream;\n      this.error = error != null ? error : DocoptExit;\n      stream = source.constructor === String ? source._split() : source;\n      this.push.apply(this, stream);\n    }\n\n    Tokens.prototype.move = function() {\n      if (this.length) {\n        return [].shift.apply(this);\n      } else {\n        return null;\n      }\n    };\n\n    Tokens.prototype.current = function() {\n      if (this.length) {\n        return this[0];\n      } else {\n        return null;\n      }\n    };\n\n    Tokens.from_pattern = function(source) {\n      var s;\n      source = source.replace(/([\\[\\]\\(\\)\\|]|\\.\\.\\.)/g, ' $1 ');\n      source = (function() {\n        var j, len, ref, results;\n        ref = source.split(/\\s+|(\\S*<.*?>)/);\n        results = [];\n        for (j = 0, len = ref.length; j < len; j++) {\n          s = ref[j];\n          if (s) {\n            results.push(s);\n          }\n        }\n        return results;\n      })();\n      return new Tokens(source, DocoptLanguageError);\n    };\n\n    return Tokens;\n\n  })(Array);\n\n  parse_section = function(name, source) {\n    var matches, s;\n    matches = source.match(new RegExp('^([^\\n]*' + name + '[^\\n]*\\n?(?:[ \\t].*?(?:\\n|$))*)', 'igm'));\n    if (matches) {\n      return (function() {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = matches.length; j < len; j++) {\n          s = matches[j];\n          results.push(s.trim());\n        }\n        return results;\n      })();\n    }\n    return [];\n  };\n\n  parse_shorts = function(tokens, options) {\n    \"shorts ::= '-' ( chars )* [ [ ' ' ] chars ] ;\";\n    var left, o, parsed, ref, ref1, short, similar, token, value;\n    token = tokens.move();\n    console.assert(token.startsWith('-') && !token.startsWith('--'));\n    left = token.replace(/^-+/g, '');\n    parsed = [];\n    while (left !== '') {\n      ref = ['-' + left[0], left.slice(1)], short = ref[0], left = ref[1];\n      similar = (function() {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = options.length; j < len; j++) {\n          o = options[j];\n          if (o.short === short) {\n            results.push(o);\n          }\n        }\n        return results;\n      })();\n      if (similar.length > 1) {\n        throw new tokens.error(short + \" is specified ambiguously \" + similar.length + \" times\");\n      } else if (similar.length < 1) {\n        o = new Option(short, null, 0);\n        options.push(o);\n        if (tokens.error === DocoptExit) {\n          o = new Option(short, null, 0, true);\n        }\n      } else {\n        o = new Option(short, similar[0].long, similar[0].argcount, similar[0].value);\n        value = null;\n        if (o.argcount !== 0) {\n          if (left === '') {\n            if ((ref1 = tokens.current()) === null || ref1 === '--') {\n              throw new tokens.error(short + \" requires argument\");\n            }\n            value = tokens.move();\n          } else {\n            value = left;\n            left = '';\n          }\n        }\n        if (tokens.error === DocoptExit) {\n          o.value = value !== null ? value : true;\n        }\n      }\n      parsed.push(o);\n    }\n    return parsed;\n  };\n\n  parse_long = function(tokens, options) {\n    \"long ::= '--' chars [ ( ' ' | '=' ) chars ] ;\";\n    var argcount, eq, long, longs, o, ref, ref1, similar, value;\n    ref = tokens.move().partition('='), long = ref[0], eq = ref[1], value = ref[2];\n    console.assert(long.startsWith('--'));\n    if (eq === value && value === '') {\n      value = null;\n    }\n    similar = (function() {\n      var j, len, results;\n      results = [];\n      for (j = 0, len = options.length; j < len; j++) {\n        o = options[j];\n        if (o.long === long) {\n          results.push(o);\n        }\n      }\n      return results;\n    })();\n    if (tokens.error === DocoptExit && similar.length === 0) {\n      similar = (function() {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = options.length; j < len; j++) {\n          o = options[j];\n          if (o.long && o.long.startsWith(long)) {\n            results.push(o);\n          }\n        }\n        return results;\n      })();\n    }\n    if (similar.length > 1) {\n      longs = ((function() {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = similar.length; j < len; j++) {\n          o = similar[j];\n          results.push(o.long);\n        }\n        return results;\n      })()).join(', ');\n      throw new tokens.error(long + \" is not a unique prefix: \" + longs + \"?\");\n    } else if (similar.length < 1) {\n      argcount = eq === '=' ? 1 : 0;\n      o = new Option(null, long, argcount);\n      options.push(o);\n      if (tokens.error === DocoptExit) {\n        o = new Option(null, long, argcount, argcount > 0 ? value : true);\n      }\n    } else {\n      o = new Option(similar[0].short, similar[0].long, similar[0].argcount, similar[0].value);\n      if (o.argcount === 0) {\n        if (value !== null) {\n          throw new tokens.error(o.long + \" must not have an argument\");\n        }\n      } else {\n        if (value === null) {\n          if ((ref1 = tokens.current()) === null || ref1 === '--') {\n            throw new tokens.error(o.long + \" requires argument\");\n          }\n          value = tokens.move();\n        }\n      }\n      if (tokens.error === DocoptExit) {\n        o.value = value !== null ? value : true;\n      }\n    }\n    return [o];\n  };\n\n  parse_pattern = function(source, options) {\n    var result, tokens;\n    tokens = Tokens.from_pattern(source);\n    result = parse_expr(tokens, options);\n    if (tokens.current() !== null) {\n      throw new tokens.error('unexpected ending: ' + (tokens.join(' ')));\n    }\n    return new Required(result);\n  };\n\n  parse_expr = function(tokens, options) {\n    \"expr ::= seq ( '|' seq )* ;\";\n    var result, seq;\n    seq = parse_seq(tokens, options);\n    if (tokens.current() !== '|') {\n      return seq;\n    }\n    result = seq.length > 1 ? [new Required(seq)] : seq;\n    while (tokens.current() === '|') {\n      tokens.move();\n      seq = parse_seq(tokens, options);\n      result = result.concat(seq.length > 1 ? [new Required(seq)] : seq);\n    }\n    if (result.length > 1) {\n      return [new Either(result)];\n    } else {\n      return result;\n    }\n  };\n\n  parse_seq = function(tokens, options) {\n    \"seq ::= ( atom [ '...' ] )* ;\";\n    var atom, ref, result;\n    result = [];\n    while ((ref = tokens.current()) !== null && ref !== ']' && ref !== ')' && ref !== '|') {\n      atom = parse_atom(tokens, options);\n      if (tokens.current() === '...') {\n        atom = [new OneOrMore(atom)];\n        tokens.move();\n      }\n      result = result.concat(atom);\n    }\n    return result;\n  };\n\n  parse_atom = function(tokens, options) {\n    \"atom ::= '(' expr ')' | '[' expr ']' | 'options'\\n| long | shorts | argument | command ;\";\n    var matching, patternType, ref, result, token;\n    token = tokens.current();\n    result = [];\n    if (indexOf.call('([', token) >= 0) {\n      tokens.move();\n      ref = {\n        '(': [')', Required],\n        '[': [']', Optional]\n      }[token], matching = ref[0], patternType = ref[1];\n      result = new patternType(parse_expr(tokens, options));\n      if (tokens.move() !== matching) {\n        throw new tokens.error(\"Unmatched '\" + token + \"'\");\n      }\n      return [result];\n    } else if (token === 'options') {\n      tokens.move();\n      return [new OptionsShortcut];\n    } else if (token.startsWith('--') && token !== '--') {\n      return parse_long(tokens, options);\n    } else if (token.startsWith('-') && (token !== '-' && token !== '--')) {\n      return parse_shorts(tokens, options);\n    } else if (token.startsWith('<') && token.endsWith('>') || token.isUpper()) {\n      return [new Argument(tokens.move())];\n    } else {\n      return [new Command(tokens.move())];\n    }\n  };\n\n  parse_argv = function(tokens, options, options_first) {\n    var parsed, v;\n    if (options_first == null) {\n      options_first = false;\n    }\n    \"Parse command-line argument vector.\\nIf options_first:\\n    argv ::= [ long | shorts ]* [ argument ]* [ '--' [ argument ]* ] ;\\nelse:\\n    argv ::= [ long | shorts | argument ]* [ '--' [ argument ]* ] ;\";\n    parsed = [];\n    while (tokens.current() !== null) {\n      if (tokens.current() === '--') {\n        return parsed.concat((function() {\n          var j, len, results;\n          results = [];\n          for (j = 0, len = tokens.length; j < len; j++) {\n            v = tokens[j];\n            results.push(new Argument(null, v));\n          }\n          return results;\n        })());\n      } else if (tokens.current().startsWith('--')) {\n        parsed = parsed.concat(parse_long(tokens, options));\n      } else if (tokens.current().startsWith('-') && tokens.current() !== '-') {\n        parsed = parsed.concat(parse_shorts(tokens, options));\n      } else if (options_first) {\n        return parsed.concat((function() {\n          var j, len, results;\n          results = [];\n          for (j = 0, len = tokens.length; j < len; j++) {\n            v = tokens[j];\n            results.push(new Argument(null, v));\n          }\n          return results;\n        })());\n      } else {\n        parsed.push(new Argument(null, tokens.move()));\n      }\n    }\n    return parsed;\n  };\n\n  parse_defaults = function(doc) {\n    var _, defaults, even, j, len, odd, options, ref, ref1, s, s1, s2, split, v;\n    defaults = [];\n    ref = parse_section('options:', doc);\n    for (j = 0, len = ref.length; j < len; j++) {\n      s = ref[j];\n      ref1 = s.partition(':'), _ = ref1[0], _ = ref1[1], s = ref1[2];\n      split = ('\\n' + s).split(new RegExp('\\\\n[ \\\\t]*(-\\\\S+?)')).slice(1);\n      odd = (function() {\n        var len1, q, results;\n        results = [];\n        for (q = 0, len1 = split.length; q < len1; q += 2) {\n          v = split[q];\n          results.push(v);\n        }\n        return results;\n      })();\n      even = (function() {\n        var len1, q, ref2, results;\n        ref2 = split.slice(1);\n        results = [];\n        for (q = 0, len1 = ref2.length; q < len1; q += 2) {\n          v = ref2[q];\n          results.push(v);\n        }\n        return results;\n      })();\n      split = (function() {\n        var len1, q, ref2, ref3, results;\n        ref2 = zip(odd, even);\n        results = [];\n        for (q = 0, len1 = ref2.length; q < len1; q++) {\n          ref3 = ref2[q], s1 = ref3[0], s2 = ref3[1];\n          results.push(s1 + s2);\n        }\n        return results;\n      })();\n      options = (function() {\n        var len1, q, results;\n        results = [];\n        for (q = 0, len1 = split.length; q < len1; q++) {\n          s = split[q];\n          if (s.startsWith('-')) {\n            results.push(Option.parse(s));\n          }\n        }\n        return results;\n      })();\n      defaults.push.apply(defaults, options);\n    }\n    return defaults;\n  };\n\n  formal_usage = function(section) {\n    var _, pu, ref, s;\n    ref = section.partition(':'), _ = ref[0], _ = ref[1], section = ref[2];\n    pu = section._split();\n    return '( ' + ((function() {\n      var j, len, ref1, results;\n      ref1 = pu.slice(1);\n      results = [];\n      for (j = 0, len = ref1.length; j < len; j++) {\n        s = ref1[j];\n        results.push(s === pu[0] ? ') | (' : s);\n      }\n      return results;\n    })()).join(' ') + ' )';\n  };\n\n  extras = function(help, version, options, doc) {\n    var o;\n    if (help && any((function() {\n      var j, len, ref, results;\n      results = [];\n      for (j = 0, len = options.length; j < len; j++) {\n        o = options[j];\n        results.push(((ref = o.name) === '--help' || ref === '-h') && o.value);\n      }\n      return results;\n    })())) {\n      return doc.replace(/^\\s*|\\s*$/, '');\n    }\n    if (version && any((function() {\n      var j, len, results;\n      results = [];\n      for (j = 0, len = options.length; j < len; j++) {\n        o = options[j];\n        results.push((o.name === '--version') && o.value);\n      }\n      return results;\n    })())) {\n      return version;\n    }\n    return \"\";\n  };\n\n  Dict = (function(superClass) {\n    extend(Dict, superClass);\n\n    function Dict(pairs) {\n      var j, key, len, ref, value;\n      for (j = 0, len = pairs.length; j < len; j++) {\n        ref = pairs[j], key = ref[0], value = ref[1];\n        this[key] = value;\n      }\n    }\n\n    Dict.prototype.toObject = function() {\n      var dict, j, len, name, ref;\n      dict = {};\n      ref = Object.keys(this).sort();\n      for (j = 0, len = ref.length; j < len; j++) {\n        name = ref[j];\n        dict[name] = this[name];\n      }\n      return dict;\n    };\n\n    return Dict;\n\n  })(Object);\n\n  docopt = function(doc, kwargs) {\n    var a, allowedargs, arg, argv, collected, doc_options, e, exit, help, i, j, left, len, matched, name, options, options_first, options_shortcut, output, pattern, pattern_options, pattern_options_strings, ref, ref1, usage_sections, version;\n    if (kwargs == null) {\n      kwargs = {};\n    }\n    allowedargs = ['argv', 'name', 'help', 'version', 'options_first', 'exit'];\n    for (arg in kwargs) {\n      if (indexOf.call(allowedargs, arg) < 0) {\n        throw new Error(\"unrecognized argument to docopt: \");\n      }\n    }\n    argv = kwargs.argv === void 0 ? process.argv.slice(2) : kwargs.argv;\n    name = kwargs.name === void 0 ? null : kwargs.name;\n    help = kwargs.help === void 0 ? true : kwargs.help;\n    version = kwargs.version === void 0 ? null : kwargs.version;\n    options_first = kwargs.options_first === void 0 ? false : kwargs.options_first;\n    exit = kwargs.exit === void 0 ? true : kwargs.exit;\n    try {\n      usage_sections = parse_section('usage:', doc);\n      if (usage_sections.length === 0) {\n        throw new DocoptLanguageError('\"usage:\" (case-insensitive) not found.');\n      }\n      if (usage_sections.length > 1) {\n        throw new DocoptLanguageError('More than one \"usage:\" (case-insensitive).');\n      }\n      DocoptExit.usage = usage_sections[0];\n      options = parse_defaults(doc);\n      pattern = parse_pattern(formal_usage(DocoptExit.usage), options);\n      argv = parse_argv(new Tokens(argv), options, options_first);\n      pattern_options = pattern.flat(Option);\n      ref = pattern.flat(OptionsShortcut);\n      for (j = 0, len = ref.length; j < len; j++) {\n        options_shortcut = ref[j];\n        doc_options = parse_defaults(doc);\n        pattern_options_strings = (function() {\n          var len1, q, results;\n          results = [];\n          for (q = 0, len1 = pattern_options.length; q < len1; q++) {\n            i = pattern_options[q];\n            results.push(i.toString());\n          }\n          return results;\n        })();\n        options_shortcut.children = doc_options.filter(function(item) {\n          var ref1;\n          return ref1 = item.toString(), indexOf.call(pattern_options_strings, ref1) < 0;\n        });\n      }\n      output = extras(help, version, argv, doc);\n      if (output) {\n        if (exit) {\n          print(output);\n          process.exit();\n        } else {\n          throw new Error(output);\n        }\n      }\n      ref1 = pattern.fix().match(argv), matched = ref1[0], left = ref1[1], collected = ref1[2];\n      if (matched && left.length === 0) {\n        return new Dict((function() {\n          var len1, q, ref2, results;\n          ref2 = [].concat(pattern.flat(), collected);\n          results = [];\n          for (q = 0, len1 = ref2.length; q < len1; q++) {\n            a = ref2[q];\n            results.push([a.name, a.value]);\n          }\n          return results;\n        })()).toObject();\n      }\n      throw new DocoptExit(DocoptExit.usage);\n    } catch (_error) {\n      e = _error;\n      if (!exit) {\n        throw e;\n      } else {\n        if (e.message) {\n          print(e.message);\n        }\n        return process.exit(1);\n      }\n    }\n  };\n\n  module.exports = {\n    docopt: docopt,\n    DocoptLanguageError: DocoptLanguageError,\n    DocoptExit: DocoptExit,\n    Option: Option,\n    Argument: Argument,\n    Command: Command,\n    Required: Required,\n    OptionsShortcut: OptionsShortcut,\n    Either: Either,\n    Optional: Optional,\n    Pattern: Pattern,\n    OneOrMore: OneOrMore,\n    Tokens: Tokens,\n    Dict: Dict,\n    transform: transform,\n    formal_usage: formal_usage,\n    parse_section: parse_section,\n    parse_defaults: parse_defaults,\n    parse_pattern: parse_pattern,\n    parse_long: parse_long,\n    parse_shorts: parse_shorts,\n    parse_argv: parse_argv\n  };\n\n}).call(this);\n"}